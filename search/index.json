[{"content":"Last month, one of my friends sent me a challenge in the reverse engineering field. In the beginning, I was busy and I could not work on this challenge. But one thing caught my eye. And it was a binary compressed using UPX.\nI tried to decompress that with the UPX program but it did not work. so I created a new binary and compared them in hexdump view. several parts related to UPX headers had changed. The bad news was that I had no idea about the headers of this program. but As you know, there is always good news among bad news :). The UPX is an Open Source Program and we can check the codes.\nMain so I started reading the UPX codes and research about headers offset (i write the links in Resources Table).\nwell, I wanted to fix the headers by reading another UPX binary. but there is a problem. UPX uses filesize for unpacking. at first, I created a fuzzer for p_filesize header bytes But it took a long time to do. suddenly I saw an amazing thing:). we can see the p_filesize field in two places. first in begin of UPX headers and second at end of the file.\nI set the byte values and unpacked the file And this is the beginning of the adventure :).\nReview now understanding the program is very easy. I opened the file in radare2 . We can do a lot of work now.\nI seek the main function and its result:\nAt first glance, we can see the strings, function names, and their arguments. but let\u0026rsquo;s see the decompiled view:\nvoid main noreturn (undefined8 param_1, int64_t param_2, int64_t param_3, int64_t param_4, int64_t param_5, undefined8 param_6, undefined8 param_7, undefined8 param_8) { uint32_t uVar1; int32_t iVar2; int64_t iVar3; int64_t arg4; int64_t arg3; int64_t in_R8; int64_t in_R9; int64_t arg7; undefined8 var_18h; int64_t var_10h; int64_t var_8h; arg4 = 0; iVar3 = sym.ptrace(0, 0, NULL, NULL); if (iVar3 != 0) { sym.puts(\u0026quot;Oh! Noway! You shouldn\\'t run me with a debugger!\u0026quot;); // WARNING: Subroutine does not return sym.exit(1); } uVar1 = sym.getuid(); if (uVar1 != 0) { sym.__printf(arg7, param_2, param_3, param_4, param_5, param_6, param_7, param_8, (int64_t)\u0026quot;UID: %d\\n\u0026quot;, (uint64_t)uVar1, arg3, arg4, in_R8, in_R9); // WARNING: Subroutine does not return sym.exit(1); } iVar3 = sym._IO_fopen64((int64_t)\u0026quot;/dev/sda\u0026quot;, 0x484062); iVar2 = sym.access(\u0026quot;/.bellaciaoo10\u0026quot;, 0); if (iVar2 == 0) { iVar2 = sym.access(\u0026quot;/root/.bellaciaoo10\u0026quot;, 0); if (iVar2 == 0) goto code_r0x00401bbd; var_10h = sym._IO_fopen64((int64_t)\u0026quot;/root/.bellaciaoo10\u0026quot;, 0x484092); } else { var_10h = sym._IO_fopen64((int64_t)\u0026quot;/.bellaciaoo10\u0026quot;, 0x484092); } sym.backup_bootloader(iVar3, (uint32_t)var_10h); code_r0x00401bbd: sym.write_bootloader(iVar3); sym.puts(\u0026quot;Wrong password.\u0026quot;); sym._IO_fclose(iVar3); sym._IO_fclose(var_10h); sym.system(\u0026quot;reboot\u0026quot;); sym._IO_fclose(iVar3); sym._IO_fclose(var_10h); // WARNING: Subroutine does not return sym.exit((uint64_t)var_18h._4_4_); }  in line 21 we can see a simple Anti Debugger that uses ptrace to detect the Debugger. Next, we see that using the getuid function checks the user access level and this is a scary point. the Program needs root access to continue Otherwise the program will stop. After all this, we get to the heart of the matter. the program open /dev/sda with r+b mode. and checks the stream with access syscall.\naccess() checks whether the calling process can access the file pathname. If pathname is a symbolic link, it is dereferenced. The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or a mask consisting of the bitwise OR of one or more of R_OK, W_OK, and X_OK. F_OK tests for the existence of the file. R_OK, W_OK, and X_OK test whether the file exists and grants read, write, and execute permissions, respectively. The check is done using the calling process's real UID and GID, rather than the effective IDs as is done when actually attempting an operation (e.g., open(2)) on the file. Similarly, for the root user, the check uses the set of permitted capabilities rather than the set of effective capabilities; and for non-root users, the check uses an empty set of capabilities. This allows set-user-ID programs and capability-endowed programs to easily determine the invoking user's authority. In other words, access() does not answer the \u0026quot;can I read/write/execute this file?\u0026quot; question. It answers a slightly different question: \u0026quot;(assuming I'm a setuid binary) can the user who invoked me read/write/execute this file?\u0026quot;, which gives set-user-ID programs the possibility to prevent malicious users from causing them to read files which users shouldn't be able to read. If the calling process is privileged (i.e., its real UID is zero), then an X_OK check is successful for a regular file if execute permission is enabled for any of the file owner, group, or other.  To continue the program tries to get a backup from the bootloader and then write its bootloader on /dev/sda . I provide you with the decompiled code of the functions:\nundefined8 sym.backup_bootloader(undefined *arg1, uint32_t arg2) { undefined8 uVar1; int64_t iVar2; int64_t in_RDX; int64_t extraout_RDX; int64_t extraout_RDX_00; undefined4 in_RSI; int64_t arg2_00; undefined *puVar3; int64_t in_FS_OFFSET; uint32_t var_20h; undefined8 stream; undefined var_dh; int32_t var_ch; int64_t var_8h; iVar2 = CONCAT44(in_RSI, arg2); var_8h = *(int64_t *)(in_FS_OFFSET + 0x28); puVar3 = arg1; if (iVar2 == 0) { uVar1 = 1; arg2_00 = iVar2; } else { arg2_00 = 0; sym.fseek(arg1, 0, 0); in_RDX = extraout_RDX; for (var_ch = 0; var_ch \u0026lt; 0x200; var_ch = var_ch + 1) { sym._IO_fread((int64_t)\u0026amp;var_dh, 1, 1, arg1); puVar3 = \u0026amp;var_dh; arg2_00 = 1; sym._IO_fwrite((int64_t)puVar3, 1, 1, iVar2); in_RDX = extraout_RDX_00; } uVar1 = 0; } iVar2 = var_8h - *(int64_t *)(in_FS_OFFSET + 0x28); if (iVar2 != 0) { uVar1 = sym.__stack_chk_fail_local(puVar3, arg2_00, in_RDX, iVar2); } return uVar1; }  undefined8 sym.write_bootloader(undefined8 arg1) { undefined8 uVar1; int64_t arg4; int64_t arg3; int64_t arg2; undefined *arg1_00; int64_t in_FS_OFFSET; undefined8 stream; int64_t var_11h; undefined uStack17; int64_t var_8h; var_8h = *(int64_t *)(in_FS_OFFSET + 0x28); var_11h._0_1_ = 0x90; stack0xffffffffffffffee = 0xaa55; sym.fseek(arg1, 0, 0); sym.puts(\u0026quot;Hello after seek\u0026quot;); for (var_11h._1_4_ = 0; ((int32_t)var_11h._1_4_ \u0026lt; 0x1fe \u0026amp;\u0026amp; (var_11h._1_4_ \u0026lt; 0x1b9)); var_11h._1_4_ = var_11h._1_4_ + 1) { sym._IO_fwrite((int64_t)(obj.bootloader + (int32_t)var_11h._1_4_), 1, 1, arg1); } sym.puts(\u0026quot;AFter loop\u0026quot;); if ((int32_t)var_11h._1_4_ \u0026lt; 0x1fd) { for (; (int32_t)var_11h._1_4_ \u0026lt; 0x1fe; var_11h._1_4_ = var_11h._1_4_ + 1) { sym._IO_fwrite((int64_t)\u0026amp;var_11h, 1, 1, arg1); } } sym._IO_fwrite((int64_t)\u0026amp;var_11h + 7, 1, 1, arg1); arg1_00 = \u0026amp;uStack17; arg2 = 1; sym._IO_fwrite((int64_t)arg1_00, 1, 1, arg1); uVar1 = 0; arg4 = var_8h - *(int64_t *)(in_FS_OFFSET + 0x28); if (arg4 != 0) { uVar1 = sym.__stack_chk_fail_local(arg1_00, arg2, arg3, arg4); } return uVar1; }  and finally, the system will reboot. result:\n   TITLE VALUE     MD5 9979b3d76b2fefde39fe3f0055120aaa   SHA1 9506c81377c74781669455927e987189fc54e704   PLATFORM GNU/LINUX   MALWARE TYPE BootKit    Resources Cujo.com\n","date":"2021-08-06","permalink":"https://sudoeruser.github.io/post/first-analysis/","tags":["UPX","Unpacking","Malware","Analyzing","Reversing"],"title":"My First Malware Analysis"},{"content":"in this post we going to checkout the WarmWelcome challenge in S4CTF(Peykar).\nCategory:Reverse\nSolution for first step, i opened the program in r2 and carefully examined the main function.\n[0x0000139f]\u0026gt; pdgo 0x0000139f |undefined8 0x0000139f |main(undefined8 param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5, | undefined8 param_6, undefined8 param_7, undefined8 param_8) |{ | undefined4 uVar1; | int32_t iVar2; | double placeholder_1; | char var_8bh [2]; | char *s; | char *buf; | char var_78h; | int32_t iStack127; | int32_t iStack123; | int64_t var_6fh; | int32_t iStack100; | char var_58h; | char var_57h; | int64_t var_56h; | char var_4eh; | int64_t var_4dh; | undefined8 req; | int64_t var_38h; | undefined8 var_28h; | undefined8 var_20h; | undefined8 var_18h; | int64_t ptr; | undefined8 size; | 0x000013aa | req = 0; 0x000013b2 | var_38h = 25000000; 0x000013ba | size = 200; 0x000013c7 | sym.ncurses_init(); 0x000013d1 | uVar1 = sym.imp.time(0); 0x000013d8 | sym.imp.srand(uVar1); 0x000013e9 | ptr = sym.imp.calloc(0x20, size); 0x000013fe | var_18h = sym.imp.calloc(0x20, size); 0x00001413 | var_20h = sym.imp.calloc(0x20, size); 0x00001428 | var_28h = sym.imp.calloc(0x20, size); 0x0000143f | sym.particle_init(ptr, size); 0x00001452 | sym.particle_init(var_18h, size); 0x00001465 | sym.particle_init(var_20h, size); 0x00001478 | sym.particle_init(var_28h, size); 0x00001681 | while (iVar2 = sym.imp.wgetch(_reloc.stdscr), iVar2 != 0x71) { 0x0000148b | placeholder_1 = (double)*(float *)(ptr + 0x18); 0x000014b2 | if ((*(double *)0x20a8 \u0026lt;= placeholder_1) || ((double)*(float *)(ptr + 0x18) \u0026lt;= *(double *)0x20b0)) { 0x000014d5 | placeholder_1 = (double)*(float *)(ptr + 0x18); 0x000014fc | if ((*(double *)0x20b8 \u0026lt;= placeholder_1) || ((double)*(float *)(ptr + 0x18) \u0026lt;= *(double *)0x20c0)) { 0x0000151c | placeholder_1 = (double)*(float *)(ptr + 0x18); 0x00001543 | if ((*(double *)0x20c8 \u0026lt;= placeholder_1) || ((double)*(float *)(ptr + 0x18) \u0026lt;= *(double *)0x20d0)) { 0x00001563 | placeholder_1 = (double)*(float *)(ptr + 0x18); 0x00001573 | if (placeholder_1 \u0026lt; *(double *)0x20d8) { 0x00001583 | sym.particle_init(ptr, size); | } | } else { 0x00001553 | sym.particle_init(var_28h, size); | } | } else { 0x0000150c | sym.particle_init(var_20h, size); | } | } else { 0x000014c2 | sym.particle_init(var_18h, size); | } 0x00001592 | sym.imp.werase(_reloc.stdscr); 0x000015a2 | sym.particle_update((uint64_t)*(uint32_t *)0x20e0, placeholder_1, param_3, param_4, param_5, param_6, param_7, 0x000015ad | param_8, ptr, size); 0x000015bd | sym.particle_update((uint64_t)*(uint32_t *)0x20e0, placeholder_1, param_3, param_4, param_5, param_6, param_7, 0x000015c8 | param_8, var_18h, size); 0x000015d8 | sym.particle_update((uint64_t)*(uint32_t *)0x20e0, placeholder_1, param_3, param_4, param_5, param_6, param_7, 0x000015e3 | param_8, var_20h, size); 0x000015f3 | sym.particle_update((uint64_t)*(uint32_t *)0x20e0, placeholder_1, param_3, param_4, param_5, param_6, param_7, 0x000015fe | param_8, var_28h, size); 0x00001611 | sym.particle_draw(ptr, size); 0x00001624 | sym.particle_draw(var_18h, size); 0x00001637 | sym.particle_draw(var_20h, size); 0x0000164a | sym.particle_draw(var_28h, size); 0x00001659 | sym.imp.wrefresh(_reloc.stdscr); 0x0000165e | sym.imp.nanosleep(\u0026amp;req, 0); | } 0x0000168e | sym.imp.free(ptr); 0x00001693 | ptr = 0; 0x000016a2 | sym.imp.free(var_18h); 0x000016a7 | var_18h = 0; 0x000016b6 | sym.imp.free(var_20h); 0x000016bb | var_20h = 0; 0x000016ca | sym.imp.free(var_28h); 0x000016cf | var_28h = 0; 0x000016d7 | sym.imp.endwin(); 0x000016e3 | sym.imp.puts(\u0026quot;Hope you enjoy the firework we prepared for you! Now give me a flag :))\\n\u0026quot;); 0x000016f9 | sym.imp.read(0, \u0026amp;buf, 0x34); 0x000016fe | sym.imp.sprintf(\u0026amp;s, 0x2051, 4); 0x00001739 | sym.imp.sprintf(var_8bh, 0x2051, 0); 0x0000173e | s._2_1_ = 0x54; 0x00001745 | s._3_1_ = 0x68; 0x0000174c | s._4_1_ = 0x33; 0x00001753 | s._5_1_ = 0x5f; 0x0000175a | s._6_1_ = 0x46; 0x00001761 | s._7_1_ = 0x31; 0x0000189e | if (((((((((char)buf == 'S') \u0026amp;\u0026amp; (buf._1_1_ == '4')) \u0026amp;\u0026amp; (buf._2_1_ == 'C')) \u0026amp;\u0026amp; 0x00001790 | ((buf._3_1_ == 'T' \u0026amp;\u0026amp; (buf._4_1_ == 'F')))) \u0026amp;\u0026amp; (buf._5_1_ == '{')) \u0026amp;\u0026amp; 0x000017b4 | ((((char)var_4dh == '}' \u0026amp;\u0026amp; 0x000017d3 | (iVar2 = sym.imp.strncmp((int64_t)\u0026amp;var_6fh + 1, \u0026quot;We1c0m3_fr0m_S4LAB\u0026quot;, 0x12), iVar2 == 0)) \u0026amp;\u0026amp; 0x000017e4 | ((buf._6_1_ == 'A' \u0026amp;\u0026amp; (((buf._7_1_ == '_' \u0026amp;\u0026amp; (var_78h == 'v')) \u0026amp;\u0026amp; (iStack123 == 0x6d726157)))))))) \u0026amp;\u0026amp; 0x00001833 | ((iVar2 = sym.imp.strncmp((int64_t)\u0026amp;var_56h + 1, (int64_t)\u0026amp;s + 2, 6, (int64_t)\u0026amp;s + 2), iVar2 == 0 \u0026amp;\u0026amp; 0x00001846 | (iStack100 == 0x6a6e655f)))) \u0026amp;\u0026amp; 0x00001857 | ((iStack127 == 0x5f797233 \u0026amp;\u0026amp; 0x00001866 | ((((char)var_6fh == (char)var_56h \u0026amp;\u0026amp; ((char)var_6fh == '_')) \u0026amp;\u0026amp; 0x00001876 | ((var_4eh == 'g' \u0026amp;\u0026amp; (((var_57h == 'y' \u0026amp;\u0026amp; (var_56h._7_1_ == (char)s)) \u0026amp;\u0026amp; (var_58h == var_8bh[0])))))))))) { 0x000018a7 | sym.imp.puts(\u0026quot;\\rOh Wow you are ready for fun!! :)\\n\u0026quot;); 0x000018c5 | return 0; | } 0x000018ba | sym.imp.puts(\u0026quot;Try harder to have fun!!\\n\u0026quot;); 0x000018c5 | return 0; |} [0x0000139f]\u0026gt;  As you can see, at the beginning of the program we have a loop that is most likely related to the fireworks display. To easily debug the program, we can disable it by Rewrite JMP Instruction in 0x0000147d address. In the following program code, the expressions printed by the puts function. also we can see read Syscall , that takes input from the user and store it in stack.\nand finally , program have a condition and this is all of the problem :D . so let\u0026rsquo;s go to set BreakPoint on conditions. The points required to set the BreakPoints are between 0x0000176c and 0x0000189c. now we ready to start debugging. For Start we most have a Specific string.I used all uppercase and lowercase letters to recognize the results. abcdefghijklmnopqrstuvwxjzABCDEFGHIJKLMNOPQRSTUVWXYZ\nin debugging process , we check values and replace it with our string letters. For convenience, you can use the following code to store data:\n#!/usr/bin/python3 deff = {} def main(): checker = \u0026quot;\u0026quot; letters = \u0026quot;abcdefghijklmnopqrstuvwxjzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot; for i in letters: deff[i] = hex(ord(i)).replace(\u0026quot;0x\u0026quot;,\u0026quot;\u0026quot;) while True: checker = input(\u0026quot;Enter letter to set value :\u0026gt;\u0026gt; \u0026quot;) if checker == \u0026quot;EXIT\u0026quot;: break value = input(\u0026quot;Enter Value :\u0026gt;\u0026gt; \u0026quot;) deff[checker] = value for i in letters: print(deff[i],end=\u0026quot;\u0026quot;) if __name__ == \u0026quot;__main__\u0026quot;: main()  and finally we got the flag :D \u0026raquo; S4CTF{A_v3ry_Warm_We1c0m3_fr0m_S4LAB_enj0y_Th3_F14g}\n","date":"2021-06-11","permalink":"https://sudoeruser.github.io/post/warm-welcome/","tags":null,"title":"Warm Welcome"}]